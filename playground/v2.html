<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Markdown Editor v2 - Direct Highlighting</title>
  <style>
    :root {
      --bg-primary: #0d1117;
      --bg-secondary: #161b22;
      --text-primary: #c9d1d9;
      --text-secondary: #8b949e;
      --border-color: #30363d;
      --line-number-bg: #161b22;
      --line-number-color: #484f58;
      --selection-bg: rgba(56, 139, 253, 0.3);
      --cursor-color: #c9d1d9;

      /* Markdown colors */
      --md-heading: #ff7b72;
      --md-bold: #ff7b72;
      --md-italic: #a5d6ff;
      --md-link: #58a6ff;
      --md-code: #7ee787;
      --md-fence: #8b949e;
      --md-list: #ff7b72;
      --md-quote: #8b949e;
      --md-hr: #484f58;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      max-width: 1000px;
      margin: 0 auto;
      padding: 16px;
      gap: 16px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    h1 {
      margin: 0;
      font-size: 1.5rem;
    }

    .editor-container {
      flex: 1;
      display: flex;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
      background: var(--bg-primary);
      min-height: 500px;
    }

    .line-numbers {
      background: var(--line-number-bg);
      color: var(--line-number-color);
      padding: 16px 0;
      text-align: right;
      user-select: none;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 14px;
      line-height: 1.5;
      min-width: 50px;
      border-right: 1px solid var(--border-color);
    }

    .line-numbers .line-number {
      padding: 0 12px 0 8px;
    }

    .editor-wrapper {
      flex: 1;
      position: relative;
      overflow: auto;
    }

    .editor-textarea,
    .editor-highlight {
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 14px;
      line-height: 1.5;
      padding: 16px;
      margin: 0;
      border: none;
      white-space: pre;
      word-wrap: normal;
      overflow-wrap: normal;
      tab-size: 2;
    }

    .editor-textarea {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: transparent;
      color: transparent;
      caret-color: var(--cursor-color);
      resize: none;
      outline: none;
      z-index: 2;
    }

    .editor-textarea::selection {
      background: var(--selection-bg);
    }

    .editor-highlight {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      min-height: 100%;
      pointer-events: none;
      z-index: 1;
      color: var(--text-primary);
    }

    /* IME composition state */
    .editor-wrapper.composing .editor-textarea {
      color: var(--text-primary);
    }

    .editor-wrapper.composing .editor-highlight {
      opacity: 0.3;
    }

    /* Markdown syntax colors */
    .md-heading { color: var(--md-heading); font-weight: bold; }
    .md-heading-marker { color: var(--md-heading); }
    .md-bold { color: var(--md-bold); font-weight: bold; }
    .md-italic { color: var(--md-italic); font-style: italic; }
    .md-bold-italic { color: var(--md-bold); font-weight: bold; font-style: italic; }
    .md-strikethrough { color: var(--text-secondary); text-decoration: line-through; }
    .md-code { color: var(--md-code); background: rgba(110, 118, 129, 0.2); border-radius: 3px; }
    .md-code-marker { color: var(--md-fence); }
    .md-fence { color: var(--md-fence); }
    .md-fence-lang { color: var(--md-code); }
    .md-link-text { color: var(--md-link); }
    .md-link-url { color: var(--text-secondary); }
    .md-link-bracket { color: var(--text-secondary); }
    .md-image { color: var(--md-link); }
    .md-list-marker { color: var(--md-list); }
    .md-blockquote { color: var(--md-quote); }
    .md-hr { color: var(--md-hr); }
    .md-html { color: var(--text-secondary); }
    .md-escape { color: var(--text-secondary); }

    /* Nested code block content */
    .code-block-content {
      /* Will be styled by language-specific highlighting */
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      padding: 8px 16px;
      background: var(--bg-secondary);
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .ime-indicator {
      position: fixed;
      bottom: 16px;
      right: 16px;
      padding: 8px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .ime-indicator.active {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Markdown Editor v2</h1>
      <span style="color: var(--text-secondary);">Direct syntax highlighting</span>
    </header>

    <div class="editor-container">
      <div class="line-numbers" id="lineNumbers"></div>
      <div class="editor-wrapper" id="editorWrapper">
        <div class="editor-highlight" id="highlight"></div>
        <textarea
          class="editor-textarea"
          id="editor"
          spellcheck="false"
          autocomplete="off"
          autocorrect="off"
          autocapitalize="off"
        ></textarea>
      </div>
    </div>

    <div class="status-bar">
      <span id="cursorPos">Line 1, Column 1</span>
      <span id="status">Ready</span>
    </div>

    <div class="ime-indicator" id="imeIndicator">IME: Composing...</div>
  </div>

  <script type="module">
    import { highlight } from '../js/lezer_api.js';

    const editor = document.getElementById('editor');
    const editorWrapper = document.getElementById('editorWrapper');
    const highlightEl = document.getElementById('highlight');
    const lineNumbersEl = document.getElementById('lineNumbers');
    const cursorPosEl = document.getElementById('cursorPos');
    const statusEl = document.getElementById('status');
    const imeIndicator = document.getElementById('imeIndicator');

    let isComposing = false;

    // Initial content
    const initialContent = `# Markdown Editor v2

This editor highlights **markdown syntax** directly.

## Features

- *Italic text* and **bold text**
- \`inline code\` with backticks
- [Links](https://example.com)

### Code Blocks

\`\`\`typescript
interface User {
  id: number;
  name: string;
}

function greet(user: User): string {
  return \`Hello, \${user.name}!\`;
}
\`\`\`

\`\`\`moonbit
pub fn hello() -> String {
  "Hello, World!"
}
\`\`\`

### Nested Markdown

\`\`\`\`md
This is nested markdown:

\`\`\`js
console.log("nested code");
\`\`\`
\`\`\`\`

> Blockquote with **bold** text

---

1. Numbered list
2. Second item
   - Nested bullet
`;

    editor.value = initialContent;

    // =========================================================================
    // Markdown Highlighting
    // =========================================================================

    function highlightMarkdown(source) {
      const lines = source.split('\n');
      const result = [];
      let inCodeBlock = false;
      let codeBlockLang = '';
      let codeBlockFenceLen = 0;
      let codeBlockContent = [];

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // Check for code fence
        const fenceMatch = line.match(/^(`{3,})([\w]*)\s*$/);

        if (fenceMatch && !inCodeBlock) {
          // Start of code block
          inCodeBlock = true;
          codeBlockFenceLen = fenceMatch[1].length;
          codeBlockLang = fenceMatch[2].toLowerCase();
          codeBlockContent = [];
          result.push(highlightFenceLine(line, fenceMatch[1], fenceMatch[2]));
        } else if (inCodeBlock) {
          // Check for end of code block
          const endFenceMatch = line.match(/^(`{3,})\s*$/);
          if (endFenceMatch && endFenceMatch[1].length >= codeBlockFenceLen) {
            // End of code block - highlight accumulated content
            const highlightedLines = highlightCodeBlockLines(codeBlockContent, codeBlockLang);
            // Replace placeholder lines with highlighted content
            const startIdx = result.length - codeBlockContent.length;
            for (let j = 0; j < highlightedLines.length; j++) {
              result[startIdx + j] = highlightedLines[j];
            }
            result.push(`<span class="md-fence">${escapeHtml(line)}</span>`);
            inCodeBlock = false;
            codeBlockLang = '';
            codeBlockContent = [];
          } else {
            // Inside code block - add to both result (as placeholder) and accumulator
            codeBlockContent.push(line);
            result.push(escapeHtml(line)); // Placeholder, will be replaced when block closes
          }
        } else {
          // Regular markdown line
          result.push(highlightMarkdownLine(line));
        }
      }

      // Handle unclosed code block
      if (inCodeBlock) {
        for (const line of codeBlockContent) {
          result.push(escapeHtml(line));
        }
      }

      return result.join('\n');
    }

    function highlightFenceLine(line, fence, lang) {
      let html = `<span class="md-fence">${escapeHtml(fence)}</span>`;
      if (lang) {
        html += `<span class="md-fence-lang">${escapeHtml(lang)}</span>`;
      }
      return html;
    }

    // Map language aliases
    const langMap = {
      'js': 'typescript',
      'javascript': 'typescript',
      'ts': 'typescript',
      'tsx': 'typescript',
      'jsx': 'typescript',
      'mbt': 'moonbit',
      'md': 'markdown',
      'markdown': 'markdown',
      'sh': 'bash',
      'shell': 'bash',
      'zsh': 'bash',
    };

    const supportedLangs = ['typescript', 'moonbit', 'json', 'html', 'css', 'bash'];

    function highlightCodeBlockLines(lines, lang) {
      if (lines.length === 0) return [];

      const mappedLang = langMap[lang] || lang;

      // For markdown blocks, recursively highlight
      if (mappedLang === 'markdown') {
        const code = lines.join('\n');
        const highlighted = highlightMarkdown(code);
        return highlighted.split('\n');
      }

      // Use our syntax highlighters for supported languages
      if (supportedLangs.includes(mappedLang)) {
        try {
          const code = lines.join('\n');
          const html = highlight(code, mappedLang);
          // Extract content from shiki output
          const match = html.match(/<code>([\s\S]*)<\/code>/);
          if (match) {
            const content = match[1];
            // Split by </span>\n<span or </span><span (end of document)
            // The format is: <span class="line">...</span>\n<span class="line">...</span>
            const result = [];
            // Simple approach: split by newline, then process each line
            const rawLines = content.split('\n');
            for (const rawLine of rawLines) {
              // Remove <span class="line"> wrapper if present
              const cleaned = rawLine
                .replace(/^<span class="line">/, '')
                .replace(/<\/span>$/, '');
              result.push(cleaned);
            }
            // Remove last empty element if exists
            if (result.length > 0 && result[result.length - 1] === '') {
              result.pop();
            }
            return result;
          }
        } catch (e) {
          console.error('Code highlight error:', e);
        }
      }

      // Fallback: just escape each line
      return lines.map(line => escapeHtml(line));
    }

    function highlightMarkdownLine(line) {
      // Empty line
      if (!line) return '';

      // Heading
      const headingMatch = line.match(/^(#{1,6})\s+(.*)$/);
      if (headingMatch) {
        const marker = headingMatch[1];
        const text = headingMatch[2];
        return `<span class="md-heading-marker">${marker}</span> <span class="md-heading">${highlightInline(text)}</span>`;
      }

      // Horizontal rule
      if (/^(\*{3,}|-{3,}|_{3,})\s*$/.test(line)) {
        return `<span class="md-hr">${escapeHtml(line)}</span>`;
      }

      // Blockquote
      const quoteMatch = line.match(/^(>\s*)(.*)$/);
      if (quoteMatch) {
        return `<span class="md-blockquote">${escapeHtml(quoteMatch[1])}</span>${highlightInline(quoteMatch[2])}`;
      }

      // List items (unordered)
      const ulMatch = line.match(/^(\s*)([-*+])\s+(.*)$/);
      if (ulMatch) {
        const indent = ulMatch[1];
        const marker = ulMatch[2];
        const text = ulMatch[3];
        return `${escapeHtml(indent)}<span class="md-list-marker">${marker}</span> ${highlightInline(text)}`;
      }

      // List items (ordered)
      const olMatch = line.match(/^(\s*)(\d+\.)\s+(.*)$/);
      if (olMatch) {
        const indent = olMatch[1];
        const marker = olMatch[2];
        const text = olMatch[3];
        return `${escapeHtml(indent)}<span class="md-list-marker">${marker}</span> ${highlightInline(text)}`;
      }

      // Regular paragraph - highlight inline elements
      return highlightInline(line);
    }

    function highlightInline(text) {
      if (!text) return '';

      let result = '';
      let i = 0;
      const len = text.length;

      while (i < len) {
        // Escaped character
        if (text[i] === '\\' && i + 1 < len) {
          result += `<span class="md-escape">${escapeHtml(text[i] + text[i + 1])}</span>`;
          i += 2;
          continue;
        }

        // Inline code
        if (text[i] === '`') {
          const endIdx = text.indexOf('`', i + 1);
          if (endIdx !== -1) {
            const code = text.slice(i + 1, endIdx);
            result += `<span class="md-code-marker">\`</span><span class="md-code">${escapeHtml(code)}</span><span class="md-code-marker">\`</span>`;
            i = endIdx + 1;
            continue;
          }
        }

        // Bold + Italic (***text*** or ___text___)
        const boldItalicMatch = text.slice(i).match(/^(\*{3}|_{3})([^\*_]+)\1/);
        if (boldItalicMatch) {
          const marker = boldItalicMatch[1];
          const content = boldItalicMatch[2];
          result += `<span class="md-bold-italic">${escapeHtml(marker)}${escapeHtml(content)}${escapeHtml(marker)}</span>`;
          i += boldItalicMatch[0].length;
          continue;
        }

        // Bold (**text** or __text__)
        const boldMatch = text.slice(i).match(/^(\*{2}|_{2})([^\*_]+)\1/);
        if (boldMatch) {
          const marker = boldMatch[1];
          const content = boldMatch[2];
          result += `<span class="md-bold">${escapeHtml(marker)}${escapeHtml(content)}${escapeHtml(marker)}</span>`;
          i += boldMatch[0].length;
          continue;
        }

        // Italic (*text* or _text_)
        const italicMatch = text.slice(i).match(/^(\*|_)([^\*_]+)\1/);
        if (italicMatch) {
          const marker = italicMatch[1];
          const content = italicMatch[2];
          result += `<span class="md-italic">${escapeHtml(marker)}${escapeHtml(content)}${escapeHtml(marker)}</span>`;
          i += italicMatch[0].length;
          continue;
        }

        // Strikethrough (~~text~~)
        const strikeMatch = text.slice(i).match(/^~~([^~]+)~~/);
        if (strikeMatch) {
          const content = strikeMatch[1];
          result += `<span class="md-strikethrough">~~${escapeHtml(content)}~~</span>`;
          i += strikeMatch[0].length;
          continue;
        }

        // Image (![alt](url))
        const imgMatch = text.slice(i).match(/^!\[([^\]]*)\]\(([^)]+)\)/);
        if (imgMatch) {
          const alt = imgMatch[1];
          const url = imgMatch[2];
          result += `<span class="md-image">![${escapeHtml(alt)}]</span><span class="md-link-bracket">(</span><span class="md-link-url">${escapeHtml(url)}</span><span class="md-link-bracket">)</span>`;
          i += imgMatch[0].length;
          continue;
        }

        // Link ([text](url))
        const linkMatch = text.slice(i).match(/^\[([^\]]+)\]\(([^)]+)\)/);
        if (linkMatch) {
          const linkText = linkMatch[1];
          const url = linkMatch[2];
          result += `<span class="md-link-bracket">[</span><span class="md-link-text">${escapeHtml(linkText)}</span><span class="md-link-bracket">](</span><span class="md-link-url">${escapeHtml(url)}</span><span class="md-link-bracket">)</span>`;
          i += linkMatch[0].length;
          continue;
        }

        // HTML tags
        const htmlMatch = text.slice(i).match(/^<[^>]+>/);
        if (htmlMatch) {
          result += `<span class="md-html">${escapeHtml(htmlMatch[0])}</span>`;
          i += htmlMatch[0].length;
          continue;
        }

        // Regular character
        result += escapeHtml(text[i]);
        i++;
      }

      return result;
    }

    function escapeHtml(text) {
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    }

    // =========================================================================
    // Editor Functions
    // =========================================================================

    function updateHighlight() {
      if (isComposing) return;

      const code = editor.value;
      try {
        const html = highlightMarkdown(code);
        highlightEl.innerHTML = html;
      } catch (e) {
        console.error('Highlight error:', e);
        highlightEl.innerHTML = escapeHtml(code);
      }
    }

    function updateLineNumbers() {
      const lines = editor.value.split('\n');
      let html = '';
      for (let i = 1; i <= lines.length; i++) {
        html += `<div class="line-number">${i}</div>`;
      }
      lineNumbersEl.innerHTML = html;
    }

    function updateCursorPosition() {
      const text = editor.value;
      const pos = editor.selectionStart;
      const beforeCursor = text.substring(0, pos);
      const lines = beforeCursor.split('\n');
      const line = lines.length;
      const column = lines[lines.length - 1].length + 1;
      cursorPosEl.textContent = `Line ${line}, Column ${column}`;
    }

    function syncScroll() {
      highlightEl.style.transform = `translate(${-editor.scrollLeft}px, ${-editor.scrollTop}px)`;
      lineNumbersEl.style.transform = `translateY(${-editor.scrollTop}px)`;
    }

    // =========================================================================
    // IME Handling
    // =========================================================================

    editor.addEventListener('compositionstart', () => {
      isComposing = true;
      editorWrapper.classList.add('composing');
      imeIndicator.classList.add('active');
      statusEl.textContent = 'IME: Composing...';
    });

    editor.addEventListener('compositionend', () => {
      isComposing = false;
      editorWrapper.classList.remove('composing');
      imeIndicator.classList.remove('active');
      statusEl.textContent = 'Ready';
      updateHighlight();
      updateLineNumbers();
    });

    // =========================================================================
    // Event Handlers
    // =========================================================================

    editor.addEventListener('input', () => {
      if (!isComposing) {
        updateHighlight();
        updateLineNumbers();
      }
      updateCursorPosition();
    });

    editor.addEventListener('scroll', syncScroll);
    editor.addEventListener('keyup', updateCursorPosition);
    editor.addEventListener('click', updateCursorPosition);

    editor.addEventListener('keydown', (e) => {
      if (e.key === 'Tab') {
        e.preventDefault();
        const start = editor.selectionStart;
        const end = editor.selectionEnd;

        // Use setRangeText for more reliable insertion
        editor.setRangeText('  ', start, end, 'end');

        updateHighlight();
        updateLineNumbers();
        updateCursorPosition();
      }
    });

    // =========================================================================
    // Initialize
    // =========================================================================

    updateHighlight();
    updateLineNumbers();
    updateCursorPosition();
    editor.focus();

    console.log('Markdown Editor v2 initialized');
  </script>
</body>
</html>
