// Generated using `moon info`, DON'T EDIT IT
package "mizchi/markdown/lezer"

// Values
pub fn escape_html(String) -> String

pub fn escape_html_slice_to(Array[Char], Int, Int, StringBuilder) -> Unit

pub fn tokens_to_html(String, Array[HighlightToken]) -> String

// Errors

// Types and methods
type CursorFrame

pub(all) enum HighlightTag {
  Keyword
  Operator
  Punctuation
  String
  Number
  Regexp
  Bool
  Null
  PropertyName
  VariableName
  FunctionName
  TypeName
  ClassName
  PrivateName
  Meta
  Bracket
  Brace
  Paren
  Comment
  DocComment
  TagName
  TagBracket
  Invalid
  None
}
pub fn HighlightTag::to_class(Self) -> String
pub impl Eq for HighlightTag
pub impl Show for HighlightTag

pub(all) struct HighlightToken {
  from : Int
  to : Int
  tag : HighlightTag
}
pub fn HighlightToken::new(Int, Int, HighlightTag) -> Self
pub impl Eq for HighlightToken
pub impl Show for HighlightToken

pub(all) struct Highlighter {
  rules : Map[String, HighlightTag]
}
pub fn Highlighter::add_rule(Self, String, HighlightTag) -> Unit
pub fn Highlighter::get_tag(Self, String) -> HighlightTag
pub fn Highlighter::highlight(Self, Tree) -> Array[HighlightToken]
pub fn Highlighter::new() -> Self

pub(all) struct NodeType {
  id : Int
  name : String
  is_error : Bool
}
pub fn NodeType::error(Int) -> Self
pub fn NodeType::new(Int, String) -> Self
pub impl Eq for NodeType
pub impl Show for NodeType

pub(all) enum Tree {
  Node(node_type~ : NodeType, from~ : Int, to~ : Int, children~ : Array[Tree])
  Leaf(node_type~ : NodeType, from~ : Int, to~ : Int)
  Buffered(buffer~ : TreeBuffer, from~ : Int, to~ : Int)
}
pub fn Tree::children(Self) -> Array[Self]
pub fn Tree::from(Self) -> Int
pub fn Tree::iter(Self) -> Iter[Self]
pub fn Tree::leaf(NodeType, Int, Int) -> Self
pub fn Tree::length(Self) -> Int
pub fn Tree::node(NodeType, Int, Int, Array[Self]) -> Self
pub fn Tree::node_type(Self) -> NodeType?
pub fn Tree::resolve(Self, Int) -> Self?
pub fn Tree::to(Self) -> Int

pub(all) struct TreeBuffer {
  data : Array[Int]
  node_types : Array[NodeType]
}
pub fn TreeBuffer::get_node(Self, Int) -> (Int, Int, Int, Int)?
pub fn TreeBuffer::new(Array[NodeType]) -> Self
pub fn TreeBuffer::node_count(Self) -> Int
pub fn TreeBuffer::push_leaf(Self, Int, Int, Int) -> Unit

pub(all) struct TreeCursor {
  root : Tree
  // private fields
}
pub fn TreeCursor::at_root(Self) -> Bool
pub fn TreeCursor::depth(Self) -> Int
pub fn TreeCursor::first_child(Self) -> Bool
pub fn TreeCursor::from(Self) -> Int
pub fn TreeCursor::name(Self) -> String
pub fn TreeCursor::new(Tree) -> Self
pub fn TreeCursor::next_sibling(Self) -> Bool
pub fn TreeCursor::node_type(Self) -> NodeType?
pub fn TreeCursor::parent(Self) -> Bool
pub fn TreeCursor::reset(Self) -> Unit
pub fn TreeCursor::to(Self) -> Int

// Type aliases

// Traits

